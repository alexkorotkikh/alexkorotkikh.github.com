
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js" lang="en"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>Шпаргалка про производительность - Singleton Post</title>
  <meta name="author" content="Alex Korotkikh">

  
  <meta name="description" content="Участвуя в конкурсе UA Web Challenge я описал в одном документе всю информацию про причины снижения произвоительности, которые я знаю. Буду рад, если &hellip;">
  

  <!-- http://t.co/dKP3o1e -->
  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  
  <link rel="canonical" href="http://alexkorotkikh.com/blog/2013/03/01/highload-problem-cheatsheet/">
  <link href="/favicon.png" rel="icon">
  <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <script src="/javascripts/modernizr-2.0.js"></script>
  <script src="/javascripts/ender.js"></script>
  <script src="/javascripts/octopress.js" type="text/javascript"></script>
  <link href="/atom.xml" rel="alternate" title="Singleton Post" type="application/atom+xml">
  <!--Fonts from Google"s Web font directory at http://google.com/webfonts -->
<link href="http://fonts.googleapis.com/css?family=PT+Serif:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href="http://fonts.googleapis.com/css?family=PT+Sans:regular,italic,bold,bolditalic" rel="stylesheet" type="text/css">
<link href='http://fonts.googleapis.com/css?family=Julius+Sans+One' rel='stylesheet' type='text/css'>
<link href='http://fonts.googleapis.com/css?family=Jura&subset=latin,cyrillic-ext,cyrillic,latin-ext' rel='stylesheet' type='text/css'>

  

</head>

<body   >
  <header role="banner"><hgroup>
  <h1><a href="/">Singleton Post</a></h1>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="/atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:alexkorotkikh.com" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">
  <li><a href="/">Blog</a></li>
  <li><a href="/blog/archives">Archives</a></li>
</ul>

</nav>
  <div id="main">
    <div id="content">
      <div>
<article class="hentry" role="article">
  
  <header>
    
      <h1 class="entry-title">Шпаргалка про производительность</h1>
    
    
      <p class="meta">
        








  


<time datetime="2013-03-01T18:00:00+01:00" pubdate data-updated="true">Mar 1<span>st</span>, 2013</time>
        
      </p>
    
  </header>


<div class="entry-content"><p><em>Участвуя в конкурсе <a href="http://uwc.org.ua">UA Web Challenge</a> я описал в одном документе всю информацию про причины снижения произвоительности, которые я знаю. Буду рад, если это кому-то пригодится. Также буду рад дополнениям и изменениям.</em></p>

<p>Проблемы производительности сильно зависят от приложения. Я постараюсь описать все известные мне типы проблем и предложить их способы решения. Каждое решение будет рассмотрено с точки зрения скорости его применения, стоимости и “фундаментальности” (насколько глубокие проблемы оно решает).</p>

<!-- more -->


<h2>Горизонтальное масштабирование</h2>

<p>Как правило, проблемы высокой нагрузки появляются внезапно, и решить их нужно как можно быстрее. С этой точки зрения увеличение количества серверов является, часто, самым простым способом. Естественно, во многих случаях это будет лечением симптомов, а не самой болезни, но это может помочь выиграть время для более детального анализа и качественного решения.</p>

<p>Плюсы:</p>

<ul>
<li>Невероятно низкое время реализации. Современные облачные платформы вроде AWS или Heroku позволяют поднять новый инстанс в течении нескольких минут. В случае собственного кластера может быть дольше и дороже, но если он качественно администрируется, добавления ещё одного сервера и развёртывание на нём приложения также не дол жно занять много времени</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Как правило, будет временным решением, кроме случаев, когда никаких других проблем нет и оптимизировать нечего (но мы же взрослые люди и понимаем, что так не бывает :)).</li>
<li>Не все проблемы могут быть решены добавлением сервера. Например, если имеет место утечка памяти, то на новом сервере память точно так же уйдёт в своп, и особого прироста производительности может не быть.</li>
<li>Увеличение расходов на инфраструктуру.</li>
</ul>


<h2>Балансировка нагрузки</h2>

<p>Самым простым алгоритмом работы балансировщика нагрузки является Round-robin, который передаёт запросы на обработку различным серверам “по кругу”, т.е., каждому по очереди, в независимости от его загруженности. Такой подход может быть не эффективным при большом количестве запросов, потому что никак не страхует от ситуации, при которой сложные, требующие большого количества ресурсов на обработку, запросы попадают на сервер, который использует свои мощности на максимуме, в то время как другой простаивает. Помочь может использование другого алгоритма, который передаёт запрос на обработку тому серверу, у которого на данный момент меньше всего занятых ресурсов.</p>

<p>Плюсы:</p>

<ul>
<li>Распределяет нагрузку равномерно по всему кластеру, значит, ресурсы используются более эффективно</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Требуется время на реализацию (или использование существующего) решения</li>
</ul>


<h2>Память</h2>

<p>Другой проблемой может быть нехватка памяти. Например, при увеличении количества запросов к приложению увеличился и объём данных, которые загружаются из БД и хранятся в памяти. Когда место в памяти закончилось, ОС начала использовать swap на жёстком диске, а работа с ним, как известно, в разы медленнее работы с оперативной памятью.
Что можно сделать в этом случае?</p>

<h3>Добавить памяти</h3>

<p>Поставить больше памяти в свой сервер или изменить тип инстанса “в облаке”, как правило, довольно просто (есть исключения, например, инстансы на Heroku имеют фиксированную конфигурацию без возможности поменять что либо)</p>

<p>Плюсы:</p>

<ul>
<li>Может быть быстро и не очень дорого</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Временное решение, поскольку нагрузка может увеличиваться практически неограниченно, а объём памяти - нет.</li>
<li>В некоторых случаях может не помочь. Если существует утечка памяти, она может съесть любой объём.</li>
</ul>


<h3>Проверить на утечки памяти</h3>

<p>Типичная проблема для языков без сборки мусора, но может встречаться и в языках, которые используют GC.</p>

<p>Плюсы:</p>

<ul>
<li>“Фундаментальное” решение.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Может занять непредсказуемое время. Профилирование и сравнение снэпшотов - довольно кропотливое и долгое занятие.</li>
</ul>


<h3>Настроить сборку мусора</h3>

<p>Платформы, которые имеют сборщик мусора (JVM, .NET etc), как правило, предоставляют широкие возможности по его тонкому тюнингу. Сам процесс сборки мусора является достаточно ресурсоёмким и может быть причиной снижения производительности.</p>

<p>Плюсы:</p>

<ul>
<li>Может привести к увеличению производительности (как существенному, так и не очень)</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Требует глубоких знаний принципов работы платформы, того, как она работает с памятью (поколения объектов, стратегии сборки и пр.)</li>
</ul>


<h2>Канал связи</h2>

<p>Для некоторых типов приложений (например, видео- или фотохостинг) пропускная способность канала может быть критичным показателем. Я вижу два способа решения этой проблемы</p>

<h3>Увеличить канал</h3>

<p>Плюсы:</p>

<ul>
<li>Может помочь, но, как и в случае с памятью, количество трафика может расти быстрее скорости увеличения канала.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Не всегда возможно, либо не всегда возможно быстро</li>
<li>Может быть очень дорого</li>
</ul>


<h3>Уменьшить количество данных</h3>

<p>Уменьшение объёма передаваемых данных может быть сделано разными способами, которые зависят от типа этих данных. В случае с бинарными данными, вроде изображений или видео, можно использовать решения вроде AWS S3, оптимизированные для подобных задач, и таким образом перенаправить трафик на другой канал данных, освободив свой собственный.</p>

<p>В случае с REST API, который, например, возвращает массив JSON-объектов, можно пересмотреть формат возвращаемых данных. Например, можно уменьшить названия полей в объекте (“lat” вместо “latitude”, “long” вместо “longitude”, “app” вместо “application” и т.д.). Это напрямую уменьшит размер HTTP ответа и поможет выиграть несколько десятков процентов от загрузки канала.</p>

<p>Другим вариантом может быть изменение структуры возвращаемых объектов. Например, могут быть ситуации, когда сервис возвращает объект из БД со всеми его связями, в то время как пользователи этого сервиса используют только несколько полей.</p>

<p>Плюсы:</p>

<ul>
<li>В некоторых случаях может принести большой эффект, с запасом</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Чем больше приложений используют API, тем больше времени потребуется на переработку. Если же API публичный и используется сторонними разработчиками, то может пройти очень много времени, прежде чем существенная их часть перепишет свои приложения для использования новой версии API.</li>
</ul>


<h2>База данных</h2>

<h3>Шардинг</h3>

<p>Для уменьшения нагрузки на сервер БД можно разнести данные по нескольким серверам (например, все данные о заказах с чётными индексами хранить на одном сервере, а с нечётными - на другом).</p>

<p>Плюсы:</p>

<ul>
<li>В случае, если структура данных позволит не делать join-ы между таблицами, которые хранятся на разных серверах, может обеспечить практически линейный рост производительности.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Приложение должно знать о том, с какой базой в каком случае нужно работать.</li>
</ul>


<h3>Пул соединений</h3>

<p>Плюсы:</p>

<ul>
<li>Правильно подобранный размер пула обеспечит и уменьшение времени отклика, и более эффективное использование памяти.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Вычислить правильный размер пула не всегда просто, однако <a href="http://stackoverflow.com/questions/1800340/how-to-calculate-the-size-for-a-database-connection-pool">способы есть</a>.</li>
</ul>


<h3>Оптимизация запросов</h3>

<p>Данная проблема особенно актуальна при использовании ORM, так как тот SQL-код, который ими генерируется, не обязательно будет оптимальным. Например, необходимо быть уверенным, что запрос на выборку данных из таблицы А не выгружает заодно и данные из таблицы Б, которая связана с А отношением один-ко-многим (естественно, если данные из Б в данном случае не нужны).</p>

<p>Плюсы:</p>

<ul>
<li>В некоторых случаях возможно увеличение производительности на порядок.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Поиск проблемных запросов может занять неопределённе время.</li>
<li>Их оптимизация - тоже.</li>
</ul>


<h3>Кэш второго уровня (результатов запросов)</h3>

<p>Плюсы:</p>

<ul>
<li>Достаточно простая реализация при использовании некоторых стандартных технологий (например, Hibernate + Ehcache)</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Нетривиально и небыстро, если нужно делать с нуля.</li>
<li>Могут быть проблемы в связке с горизонтальным масштабированием. Если инстансы ничего не знают друг про друга, необходим новый сервер, доступ к которому будут иметь все инстансы. Однако, в этом случае эффективность кэша может упасть из-за увеличения сетевых издержек.</li>
</ul>


<h3>Отказ от реляционной модели</h3>

<p>NoSQL сейчас в моде, и в некоторых случаях он действительно может быть полезен. Проблема в том, что нельзя просто заменить MySQL на MongoDB и ожидать большого прироста производительности. Модель данных определяет способы работы с этими данными, и её изменение влечёт за собой изменения способов взаимодействия. Это требует серьёзного “сдвига парадигмы” у разработчиков.
Многократное увеличение производительности в случаях, когда данные хорошо ложатся на новую модель данных (document-oriented, column-based, key-value etc).</p>

<p>Плюсы:</p>

<ul>
<li>Как правило, более простое горизонтальное масштабирование.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Издержки на изучение новой технологии, реализацию решения, тестирование, миграцию данных</li>
<li>При неправильном использовании может стать только хуже</li>
</ul>


<h2>Асинхронное выполнение задач</h2>

<p>Часть задач может быть выполнена уже после того, как пользователь получил ответ от сервера. Например, если одно из его действий должно инициировать отправку ему электронной почты, он может и не заметить, если почта придёт не через 3 секунды, а через полминуты. Подобные задачи можно ставить в очередь, а их обработку поручить другим серверам, которые не будут отвечать на HTTP-запросы, а будут заниматься только подобными асинхронными, background, задачами.</p>

<p>Плюсы:</p>

<ul>
<li>Снижает время отклика для некоторых запросов (как правило, не для всех)</li>
<li>Освобождает ресурсы серверов, которые отвечает на запросы</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Реализация может потребовать достаточно много времени</li>
<li>Не все задачи можно выполнять асинхронно</li>
</ul>


<h2>Статические файлы</h2>

<h3>Кэширование статики</h3>

<p>Плюсы:</p>

<ul>
<li>Уменьшает нагрузку как на веб-сервер, так и на канал</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Если большинство клиентов - не браузеры (а, например, мобильные клиенты или другие веб-сервисы), они могут не поддерживать кэширование (HTTP-заголовки вроде Cache-Control и Expires), и изменения не будут иметь смысла</li>
</ul>


<h3>CDN</h3>

<p>Специализированные сервисы для раздачи статики, вроде AWS S3 или CloudFront, которые уже оптимизированы для таких задач.</p>

<p>Плюсы:</p>

<ul>
<li>Уменьшает нагрузку как на веб-сервер, так и на канал</li>
<li>В некоторых случаях может быть быстро и просто</li>
</ul>


<p>Минусы:</p>

<ul>
<li>В некоторых случаях может быть долго и сложно</li>
<li>Увеличение расходов на инфраструктуру</li>
</ul>


<h2>Внешние сервисы</h2>

<p>Для выполнение некоторых задач могут быть использованы веб-сервисы, предоставляемые внешними вендорами. Такое решение хорошо тем, что там не нужно самим реализовывать некоторые функции, а можно использовать то, что сделали другие. Но вместе с тем мы получаем отсутствие контроля над некоторыми аспектами приложения, в том числе и над временем выполнения.</p>

<h3>Замена внешнего сервиса внутренним</h3>

<p>Плюсы:</p>

<ul>
<li>Уменьшение (часто - существенное) времени обработки запросов (за счёт отсутствия необходимости делать запросы по сети)</li>
<li>Увеличение контроля над определённым функционалом приложения.</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Реализация может занять длительное время</li>
<li>Увеличение количества поддерживаемого кода.</li>
</ul>


<h3>Сделать работу с внешними сервисами асинхронной</h3>

<p>См. раздел Асинхронное выполнение задач</p>

<h2>Несоответствие технологий</h2>

<p>Самый крайний случай. Все, наверное, знают историю про то, что Твиттер изначально был написан на Ruby on Rails, и быстрый рост популярности приводил к частым простоям сервиса. Было принято решение перейти на JVM (Java + Scala), и через некоторое время количество даунтаймов существенно снизилось.</p>

<p>Может оказаться, что выбранная платформа плохо подходит для высокой нагрузки (например, в Ruby на тот момент не было “честных” потоков, и работа с памятью в JVM сделана на порядок эффективней), и в долгосрочной перспективе может оказаться выгодным поменять технологический стек.</p>

<p>Плюсы:</p>

<ul>
<li>Любимая программистами возможность “выбросить всё и начать с нуля”</li>
</ul>


<p>Минусы:</p>

<ul>
<li>Ни о каком “быстром решении” не может быть и речи - будет долго и, соответственно, дорого.</li>
</ul>

</div>


  <footer>
    <p class="meta">
      
  

<span class="byline author vcard">Posted by <span class="fn">Alex Korotkikh</span></span>

      








  


<time datetime="2013-03-01T18:00:00+01:00" pubdate data-updated="true">Mar 1<span>st</span>, 2013</time>
      


    </p>
    
      <div class="sharing">
  
  <a href="http://twitter.com/share" class="twitter-share-button" data-url="http://alexkorotkikh.com/blog/2013/03/01/highload-problem-cheatsheet/" data-via="" data-counturl="http://alexkorotkikh.com/blog/2013/03/01/highload-problem-cheatsheet/" >Tweet</a>
  
  
  
</div>

    
    <p class="meta">
      
      
    </p>
  </footer>
</article>

</div>

<aside class="sidebar">
  
    <section>
  <h1>Recent Posts</h1>
  <ul id="recent_posts">
    
      <li class="post">
        <a href="/blog/2013/03/01/highload-problem-cheatsheet/">Шпаргалка про производительность</a>
      </li>
    
  </ul>
</section>






  
</aside>


    </div>
  </div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2013 - Alex Korotkikh -
  <span class="credit">Powered by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>
  







  <script type="text/javascript">
    (function(){
      var twitterWidgets = document.createElement('script');
      twitterWidgets.type = 'text/javascript';
      twitterWidgets.async = true;
      twitterWidgets.src = 'http://platform.twitter.com/widgets.js';
      document.getElementsByTagName('head')[0].appendChild(twitterWidgets);
    })();
  </script>





</body>
</html>
